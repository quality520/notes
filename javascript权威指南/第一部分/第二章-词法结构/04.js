


//属性访问表达式
//属性访问表达式运算得到一个对象属性或一个数组元素的值。javascript为属性访问定义了两种语法
//    expression.indentifier
//    expression[expression]
//第一种写法是一个表达式后跟随一个句点和标识符。表达式指定对象，标识符则指定需要访问的属性的名称。
//第二种写法是使用方括号，方括号内是另外一个表达式(这种方法适用于对象和数组)。这种表达式指定要访问的属性的名称或者代表要访问数组元素的索引
//显然.identifier的写法更加简单，但需要注意的是，这种方式只适合于要访问的属性名称是合法的标识符，并且需要知道要访问的属性的名字
//如果名称是一个保留字或者包含空格和标点符号，或者是一个数字，则必须使用方括号的写法



var  o = {x:1,y:{z:3}};//==>一个示例对象
var a = [0,4,[5,6]];    //==>一个包含这个对象的示例数组
o.x;                    //==>1;表达式o的x属性
o.y;                    //==>{z:3}表达式o的y属性
o.y.z;                  //==>3表达式o.y的z属性
o["x"];                 //==>1;对象o的x属性
o["y"];                 //==>{z:3}对象o的y属性
o["y"]["z"];            //==>3对象o.y的z属性
a[1];                   //==>4表达式a中索引为1的元素
a[2];                   //==>[5,6]
a[2][1];                //==>6表达式a[2]中索引为1的元素



var a =function(){
    var a = 1;
    var b = 2;
    return [a,b];
}
a()[0];             //==>1；获取a函数返回的数组的第一个对象

//"+"运算符
//二元加法运算符“+”可以对两个数字做加法，也可以做字符串链接操作
//加号的转换规则优先考虑字符串连接 ，如果其中一个操作数是字符串或者转换为字符串的对象，
//另外一个操作数将会转换为字符串，加法将进行字符串的连接操作。
//如果两个操作数都不是类字符串(string-like)的，那么都将进行加法运算。
//从技术上讲，加法操作符的行为表现为：
//1，如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值：日期对象通过
//  toString()方法执行转换，其他对象则通过valueOf()方法执行转换(如果valueOf()方法返回一个原始值的话)
//  由于多数对象都不具备可用的valueOf()方法，因此他们会通过toString()方法来执行转换。
//2，在进行对象到原始值的转换后，如果其中一个操作数是字符串的话，另外一个操作数也会转换为字符串，然后进行字符串连接
//3，否则，两个操作数都将转换为数字(或者NaN)，然后进行加法操作。
    1 + 2;      //==>3:加法
    "1" + "2";  //==>"12"；字符串连接
    "1" + 2;  //==>"12"；字符串连接,数字转换为字符串后进行字符串连接
    1 + {};     //==>"1[object Object]";对象转换为字符串后进行字符串连接
    true + true;    //==>2;布尔值转换为数字后做加法
    2 + null;   //==>2;null转换为0后做加法
    2 + underfined; //==>NaN;underfined转换为NaN后做加法

//需要特别注意的是;当加号运算符和字符串和数字一起使用的时，需要考虑加法的结核性的对运算顺序的影响
//也就是说，运算结果是依赖与运算符的运算顺序的。

1 + 2 +"hello world!";      //==>"3hello world!"
1 + (2 +"hello world!");    //==>"12hello world!"

//一元算术运算符
// + - ++ --
var i = 1;
i++;        //==>1
++i;        //==>2;
i--;        //==>1;
--i;        //==>0;

//位运算符
//  位与(&);位运算符“&”对它的整型操作数逐位执行布尔与(AND)操作。只有两个操作数中相对的位都是1，结果才为1；
        var a = 1;
        var b = 2;
        var c = 3;
        if(a>b && c>b){
            console.log("成功！");
        }else{
            console.log("失败！");
        }
    //==>失败！
//  位或(|);位运算符“|”对它的整型操作数逐位执行布尔或(OR)操作。如果其中一个操作数相应的位为1，或者两个操作数相应位都是1，那么结果就为1；

        var a = 1;
        var b = 2;
        var c = 3;
        if(a>b | c>b){
            console.log("成功！");
        }else{
            console.log("失败！");
        }
    //==>成功！
        var a = 1;
        var b = 2;
        var c = 3;
        if(b>a | c>b){
            console.log("成功！");
        }else{
            console.log("失败！");
        }
    //==>成功！
//  位异或(^);位运算符“^”对它的整型操作数逐位执行布尔异或(XOR)操作。异或是指第一个操作数为true或第二个操作数为true，但两者不能同时为true。如果两个操作数中只有一个相应位为1(不能同时为1)，那么结果为1；
        var a = 1;
        var b = 2;
        var c = 3;
        if(b>a ^ c>b){
            console.log("成功！");
        }else{
            console.log("失败！");
        }
    //==>失败！
        var a = 1;
        var b = 2;
        var c = 3;
        if(a>b ^ c>b){
            console.log("成功！");
        }else{
            console.log("失败！");
        }
    //==>成功！

//  位非(~);运算符“~”是一元运算符，位于一个整型参数之前，它将操作数的所有位取反。根据javascript中带符号的整数的表示方法，对一个值使用“~”运算相当于改变它的符号并减1；
        var a =  5;
        ~a;             //==>-6;

//逻辑表达式
//逻辑运算符"&&"/、"||"、"!"是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式。
//逻辑与(&&)三个不同层次的理解
//一、当操作数都是布尔值的时候，"&&"对两个执行布尔与(AND)操作，只有子啊第一个操作数和第二个操作数都是true的时候，它才返回true。如果其中一个操作数书false，它返回false。
    var x = 0;
    var y = 0;
    if(x == 0 && y ==0)    //只有在x和y都是0的时候，才返回true
    {
        ++x; ++y;
        console.log(x + y); //==>2;
    }
//二、"&&"可以对真值和假值进行布尔与(AND)操作。如果两个操作数都是真值，那么返回一个真值；否则，至少一个操作数是假值的话，则返回一个假值。
//在javascript中任何希望使用布尔值的地方，表达式和语句都会将其当做真值来对待。因此实际上"&&"并不总是返回true和false。
//假值：false、null、undefined、0、-0、NaN和"",所有其他的值担保多所有对象都是真值。

//三、运算符首先计算左操作数的值，即首先计算“&&”z左侧的表达式。如果计算结果是假值，那么整个表达式的结果一定也是假值，因此"&&"这时简单的返回做操作数的值，而并不会对右操作数进行计算。
//反过来讲，如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。如果右操作数是真值，那么整个表达式的值一定是真值；如果右操作数是假值，那么整个表达式的值一定是假值。
            var sport={x:1,y:2};
            var y = null;
            if(sport && sport.x){           //==>返回true
                console.log("true");
            }
            if(y && y.y){                   //==>返回false
                console.log("hello")}
            else{
                console.log("false");
            }
//ps:“&&”的行为有时候称做“短路”(short circuiting)，下面两行javascript代码是完全等价的；
    if(a == b) stop();      //==>只有在a==b的时候才调用stop()
    a == b && stop();       //==同上


//逻辑或(||)
//"||"运算符对两个操作数做布尔或(OR)运算。如果其中一个或者两个操作数是真值，它返回一个真值。如果两个操作数都是假值，它返回一个假值。
//逻辑或"||"，它也会首先计算第一个操作数的值，如果左侧值是真值，那么返回这个真值。否则，再计算第二个操作数的值，即计算右侧的表达式，并返回这个表达式的计算结果。
        //如果max_width已经定义了，直接使用它，否则preferences对象中查找max_width
        //如果没有找到定义它，则使用一个写死的常量
        var max = max_width || preferences.max_width || 500;
//这种惯用法常用在函数体内，用来给参数提供默认值;
        //将o的成员属性复制到p中，并返回p
        function copy(o,p){
            p = p || {};    //如果向参数p传入任何对象，则使用一个新创建的对象
            //函数体内的主逻辑
        }

//逻辑非(!)
//"!"运算符是一元运算符。它防止在一个单独的操作数之前。它的目的是将操作数的布尔值进行求反。例如，如果x是真值，则！x返回false，如果x是假值，则！x返回true；
//"！"运算符首先将其操作数转换为布尔值，然后再对布尔值求反，也就是说“！”总是反水true或者false，并且，可以通过使用两次逻辑非运算来得到一个值的等价布尔值：!!x
//"!"具有很高的优先级，并且和操作数紧密绑定在一起。如果你希望对类似p && q的表达式进行求反操作，则需要使用括号：!(p && q).
        //对于p和q取任意值，这两个灯饰都永远成立
        !(p && q) === !p || !q;
        !(p || q) === !p && !q;



// 左移(<<);将第一个操作书的所有二进制位进行左移操作，移动的位数由第二个操作数指定，移动的位数是0~31之间的一个整数。
//  例如：在表达式a<<1中，a的第一位变成了第二位，a的第二位变成了它的第三位，以此类推。新的第一位用0来补充，舍弃第32位
//  将一个值左移1位相当于它乘以2，左移两位相当于乘以4，一次类推
    4 << 2;     //==>16;
    4 << 4;     //==>64

//  带符号右移(>>)运算符“>>”将第一个操作数的所有位进行右移操作，移动的位数由第二个操作数指定，移动的位数是0~31之间的一个整数。右边溢出的位将忽略。填充在左边的位由原操作数的符号决定，以便保持结果的符号
//  与原操作数一致。如果第一个操作数是正数，移位后用0填充最高位；如果第一个操作数是负的，移动后就用1填补高位。将一个值右移1位，相当于用它除以2（忽略余数），右移两位，相当于它除以4，以此类推
    7 >> 1;      //==>3;7/2 = 3
    64 >> 5;    //==>2
//  无符号右移(>>>)运算符“>>>"和运算符">>"一样，只是右边的高位总是填补0，与原来的操作数符号无关
    -1  >> 4;       //==>-1
    -1 >>> 4;       //==>268435455

//4.9关系表达式
//相等运算符、不等运算符比较运算符和javascript中其他两个关系运算符in 和instanceof.
//"="赋值、"=="相等、"==="严格相等(恒等，数据类型的相同)

        if(true == 1){
            var enter=confirm("确定要删除吗？");
            if(enter){
                document.title = "123";
            }
        }else{
            alert("bye bye!");
        }

//比较运算符
//  小于(<)如果第一个操作数小于第二个操作数，则“<”运算符的计算结果为true；否则为false；

//  大于(>)如果第一个操作数大于第二个操作数，则“>”运算符的计算结果为true；否则为false；

//  小于等于(<=)如果第一个操作数小于等于第二个操作数，则“<”运算符的计算结果为true；否则为false；

//  大于等于(>=)如果第一个操作数大于等于第二个操作数，则“>=”运算符的计算结果为true；否则为false；

    11 < 3; //==>数字的比较，结果为false
    "11" < "3"; //==>字符串的比较，结果为true；
    "11" < 3;   //==>数字的比较，"11"转换为11，结果为false
    "one" < 3   //==>数字的比较，"one"转换为NaN，结果为false；

//in运算符；in运算符希望它的左操作数是一个字符串或可以转换为字符串，希望它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，那么表达式返回true
        var points = {x:1,y:2,z:3};
        if("x" in points){
            console.log("x 是points的属性");
        }else{
            console.log("false");
        }
    //==>x 是points的属性    对象有一个名为"x"的属性
        "z" in points;      //==>false:对象中不存在名为"z"的属性
        "toString" in points;   //==>true;对象继承了soString()方法

        var data = [1,2,3,4,5,6,7,8,9];
        "0" in data;    //==>true：数组宝航元素“0”；
        1 in data ;     //==>true;数字转换为字符串
        10 in data;      //==>false;没有索引为10 的元素

//instanceof运算符；运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true;否则返回false，
//javascript中对象的类是通过初始化他们的构造函数来定义的，这样的话，instanceof的右操作数应当是一个函数

        var d = new Date();     //==>通过Date()构造函数来创建一个新对象
        d instanceof Date;      //==>true，d是Date()创建的
        d instanceof Object;    //==>true,所有的对象都是Object的实例
        d instanceof Number;    //==>false,d不是一个Number对象

        var a = [1,2,4];        //通过数组直接量的写法创建一个数组
        a instanceof Array;     //==>true,a是一个数组

//带操作的赋值运算
    a += b;   //等价于下列表达式
    a = a + b;
//赋值运算符（+=、-+、*=、/=、%=、<<=、>>=、>>>=、&=、|=、^=）
//只有在a包含具有副作用的表达式(比如函数调用和赋值操作)的时候，两者才等价。如果下面两个表达式就不等价
data[i++] *= 2;
data[i++] = data[i++] * 2;

//表达式计算
//eval()
//eval()只有一个参数，如果传入的参数不是字符串，它直接返回这个参数。如果参数是字符串，它会把字符串当成javascript代码进行编译(parse).
            var a = {
                x:1,
                y:2,
                z:alert("123"),
                zz:5

            }
            eval(a);        //==>Object {x: 1, y: 2, z: undefined, zz: 5},并且会弹出123


//delete一元运算符，它用来删除对象或者数组元素。它是用来做删除操作的，不是用来返回一个值的。
        var o = {x:1,y:2};      //定义一个对象
        delete o.x;             //删除一个属性
        "x" in o;               //false；这个属性在对象中不在存在

        var x = [1,2,3,4,5];    //定义一个数组
        delete x[0];           //删掉数组第一个对象
        0 in x;                 //false；第一个元素在数组中已经不存在了。
        console.log(x.length);  //==>4,只是删掉了值，并没有删掉索引。
//删除属性或者删除数组元素不仅仅是设置了一个undefined的值。当删除一个属性时，这个属性将不再存在。图区一个不存在的属性将返回underfined，
//但是可以通过in运算符来检测这个 属性是否在对象中存在。

//delete希望他的操作数是一个左值，如果它不是左值，那么delete将不经信息港任何操作同时返回true。否则，delete将试图删除这个指定的左值。如果删除成功，delete将返回true。
//一些内置核心和客户端属性是不能删除的，用户通过var语句声明的变量不能删除。通过function语句定义的函数和函数参数也不能删除。

//void运算符
<a href="javascript:void window.open();">打开一个新窗口</a>
