##1.2多态

> “多态”(polymorphism)，拆开来看是poly(负数) + morph(形态) + ism，从字面上可以理解为附属形态。

>多态的含义：同一个操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一条信息的时候，这些对象会根据这个消息分别给出不同的反馈。

>case:主人家养了两只动物，分别是一只鸭和一只鸡，当主人向他们发出“叫”的命令是，鸭会“嘎嘎嘎”叫，鸡会“咯咯咯”叫。这两只动物都会以自己的方式来发出声音。他们同样“都是动物，并且可以发出声音”，但根据主人的指令，它们会各自发出不同的叫声。

####1.2.一段“多态”的JavaScript代码
```javascript
    var makeSound = function(animal){
        if (animal instanceof Duck){
            console.log("嘎嘎嘎！");
        } else if (animal instanceof Chicken){
            console.log("咯咯咯！");
        }
    }

    var Duck = function(){}
    var Chicken = function(){}

    makeSound( new Duck());  //嘎嘎嘎！
    makeSound( new Chicken());  //咯咯咯！
```

>上述代码确实体现了“多态性”，当我们分别向鸡鸭发出“叫唤”的消息时，他们根据此消息做出了各自不同的反应。

>但这样的“多态性”是无法令人满意的，如果新增一只动物，比如狗，狗的叫声“汪汪汪”，此时我们需要改动makeSound函数，才能让狗也发出叫声。修改代码总是危险的，修改的地方越多，程序出错的可能性就越大，而且当动物的种类越来越多时，makeSound有可能变成一个巨大的函数。

>多态被后的思想是将“做什么”和“谁去做以及怎么去做”分离开来，也就是将“不变的事物”与“可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们扩展程序的能力，程序看起来是可生长的，也是符合开放--封闭原则的，相对于修改代码来说，仅仅增加代码就能完成同样的功能，这显然优雅和安全很多。

####1.2.2对象的多态性

>改写后的代码，首先我们把不变的部分隔离出来，那就是所有动物都会发出叫声：

```javascript
    var makeSound = function(animal){
        animal.sound();
    }
```

>把可变的部分各自封装起来。

```javascript
    var Duck = function(){}
    Duck.prototype.sound = function(){
        console.log("嘎嘎嘎！");
    }

    var Chicken = function(){}
    Chicken.prototype.sound = function(){
        console.log("咯咯咯！");
    }

    makeSound( new Duck() );  //嘎嘎嘎
    makeSound( new Chicken() );  //咯咯咯
```

>如果动物世界里来了一条狗，这时候，只要简单的追加一些代码就可以了，而不用改动以前的makeSound函数。

```javascript
    var Dog = function(){}
    Dog.prototype.sound = function(){
        console.log("汪汪汪！");
    }

    makeSound( new Dog() ); //汪汪汪
```

####1.2.3类型检查和多态

>类型检查是在表现出对象多态性之前的一个绕不开的话题，但是JavaScript是一门不必进行类型检查的动态类型语言，为了真正了解多态的目的，我们需要转一个弯，从一门静态类型语言说起。



